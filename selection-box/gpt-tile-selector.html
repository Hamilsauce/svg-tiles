<!doctype html>
<html lang="en">

<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
  <title>Mobile-first SVG Range Selector</title>
  <style>
    :root {
      --bg: #0b0f14;
      --grid: #243042;
      --grid2: #1a2331;
      --sel: #66a3ff;
      --selFill: rgba(102, 163, 255, .18);
    }
    
    body {
      margin: 0;
      background: var(--bg);
      color: #cfd7e3;
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
    }
    
    .wrap {
      padding: 12px;
    }
    
    .card {
      border: 1px solid #1a2331;
      border-radius: 14px;
      overflow: hidden;
      background: #0d131c;
    }
    
    .header {
      display: flex;
      gap: 10px;
      align-items: center;
      padding: 10px 12px;
      border-bottom: 1px solid #1a2331;
    }
    
    .pill {
      font-size: 12px;
      padding: 6px 10px;
      border: 1px solid #1a2331;
      border-radius: 999px;
      color: #b7c3d6;
    }
    
    .note {
      font-size: 12px;
      opacity: .85;
    }
    
    svg {
      display: block;
      width: 100%;
      height: auto;
      touch-action: none;
      user-select: none;
      -webkit-user-select: none;
    }
    
    .tile {
      fill: transparent;
    }
    
    .tileStroke {
      stroke: var(--grid2);
      stroke-width: 1;
      shape-rendering: crispEdges;
    }
    
    .tileStroke.major {
      stroke: var(--grid);
    }
    
    .selRect {
      fill: var(--selFill);
      stroke: var(--sel);
      stroke-width: 2;
      vector-effect: non-scaling-stroke;
    }
    
    .handle {
      fill: #0d131c;
      stroke: var(--sel);
      stroke-width: 2;
      vector-effect: non-scaling-stroke;
    }
    
    .handleHit {
      fill: transparent;
    }
    
    .handleLine {
      stroke: var(--sel);
      stroke-width: 2;
      vector-effect: non-scaling-stroke;
      stroke-linecap: round;
    }
  </style>
</head>

<body>
  <div class="wrap">
    <div class="card">
      <div class="header">
        <div class="pill" id="rangeReadout">Range: —</div>
        <div class="note">Tap a cell to place. Drag body or handles. Snaps on release. Emits <code>rangechange</code>.</div>
      </div>
      <svg id="sheet" viewBox="0 0 360 520" aria-label="sheet"></svg>
    </div>
  </div>
  
  <script>
    /**
     * Mobile-first, Excel-style range selector on an SVG grid.
     * - Tap a cell to insert selector at 1x1.
     * - Drag body to move entire range.
     * - Drag start/end handles to resize; seamless inversion supported.
     * - Snaps to grid on drag end.
     * - Emits CustomEvent('rangechange', { detail: { start:{r,c}, end:{r,c} } })
     */
    
    class SvgRangeSelector {
      /**
       * @param {SVGSVGElement} svg
       * @param {{
       *  rows:number, cols:number,
       *  cellW:number, cellH:number,
       *  majorEvery?:number,
       *  handleRadius?:number,
       *  padding?:number,
       * }} opts
       */
      constructor(svg, opts) {
        this.svg = svg;
        this.opts = {
          majorEvery: 5,
          handleRadius: 12,
          padding: 10,
          ...opts,
        };
        
        this.rows = this.opts.rows;
        this.cols = this.opts.cols;
        this.cellW = this.opts.cellW;
        this.cellH = this.opts.cellH;
        
        // Range in cell coordinates (inclusive)
        this.range = {
          a: { r: 0, c: 0 }, // one corner
          b: { r: 0, c: 0 }, // opposite corner
        };
        
        // Drag state
        this.drag = {
          mode: null, // 'move' | 'a' | 'b'
          pointerId: null,
          startPt: null, // SVG pt at pointerdown
          startRange: null, // snapshot of range at pointerdown
          moveAnchor: null, // offset in cells for moving
        };
        
        this._build();
        this._bind();
        this.render();
      }
      
      // --- Public: set range via 1x1 cell insertion
      placeAtCell(r, c) {
        const rr = this._clamp(r, 0, this.rows - 1);
        const cc = this._clamp(c, 0, this.cols - 1);
        this.range.a = { r: rr, c: cc };
        this.range.b = { r: rr, c: cc };
        this.render();
        this._emit();
      }
      
      // --- Emit rangechange on drag end / placement
      _emit() {
        const { start, end } = this._normalizedRange();
        this.svg.dispatchEvent(
          new CustomEvent("rangechange", {
            detail: { start, end },
            bubbles: true,
            composed: true,
          })
        );
      }
      
      // --- Build SVG elements
      _build() {
        const svg = this.svg;
        
        // Size viewBox based on grid
        const w = this.opts.padding * 2 + this.cols * this.cellW;
        const h = this.opts.padding * 2 + this.rows * this.cellH;
        svg.setAttribute("viewBox", `0 0 ${w} ${h}`);
        
        // Root groups
        this.gGrid = this._el("g");
        this.gSel = this._el("g");
        
        svg.appendChild(this.gGrid);
        svg.appendChild(this.gSel);
        
        // Grid background rect (for hit, if needed)
        this.bg = this._el("rect", {
          x: 0,
          y: 0,
          width: w,
          height: h,
          fill: "transparent"
        });
        this.gGrid.appendChild(this.bg);
        
        // Grid tiles (for tap-to-place)
        this.tiles = [];
        for (let r = 0; r < this.rows; r++) {
          for (let c = 0; c < this.cols; c++) {
            const x = this._pxX(c);
            const y = this._pxY(r);
            
            // A transparent tile rect for pointer events
            const tile = this._el("rect", {
              x,
              y,
              width: this.cellW,
              height: this.cellH,
              class: "tile",
              "data-r": r,
              "data-c": c
            });
            
            // Stroke grid line (separate so tile remains transparent)
            const stroke = this._el("rect", {
              x,
              y,
              width: this.cellW,
              height: this.cellH,
              fill: "transparent",
              class: "tileStroke" + ((r % this.opts.majorEvery === 0 || c % this.opts.majorEvery === 0) ? " major" : "")
            });
            
            this.gGrid.appendChild(stroke);
            this.gGrid.appendChild(tile);
            this.tiles.push(tile);
          }
        }
        
        // Selection rect
        this.selRect = this._el("rect", { class: "selRect" });
        this.gSel.appendChild(this.selRect);
        
        // Handles: start (a) and end (b)
        this.handleA = this._makeHandle();
        this.handleB = this._makeHandle();
        this.gSel.appendChild(this.handleA.g);
        this.gSel.appendChild(this.handleB.g);
        
        // A hit rect to drag the entire selection (bigger finger target)
        this.selHit = this._el("rect", { fill: "transparent" });
        this.gSel.insertBefore(this.selHit, this.selRect);
        
        // Ensure selector is above grid
        this.gSel.style.pointerEvents = "auto";
      }
      
      _makeHandle() {
        const g = this._el("g");
        
        // Simple "drag glyph": vertical line
        const line = this._el("line", { class: "handleLine" });
        const circle = this._el("circle", { class: "handle" });
        
        // Larger invisible hit target for finger
        const hit = this._el("circle", { class: "handleHit" });
        
        g.appendChild(hit);
        g.appendChild(circle);
        g.appendChild(line);
        
        return { g, line, circle, hit };
      }
      
      // --- Bind pointer events (touch + mouse via Pointer Events)
      _bind() {
        // Tap a tile to place 1x1 selector
        for (const tile of this.tiles) {
          tile.addEventListener("pointerdown", (e) => {
            // If currently dragging something else, ignore
            if (this.drag.mode) return;
            
            const r = Number(tile.getAttribute("data-r"));
            const c = Number(tile.getAttribute("data-c"));
            
            // Place immediately on pointerdown for mobile feel
            this.placeAtCell(r, c);
            
            // Prevent background scroll on touch
            e.preventDefault();
          }, { passive: false });
        }
        
        // Drag selection body
        this.selHit.addEventListener("pointerdown", (e) => this._startDrag(e, "move"), { passive: false });
        this.selRect.addEventListener("pointerdown", (e) => this._startDrag(e, "move"), { passive: false });
        
        // Drag handles
        this.handleA.g.addEventListener("pointerdown", (e) => this._startDrag(e, "a"), { passive: false });
        this.handleB.g.addEventListener("pointerdown", (e) => this._startDrag(e, "b"), { passive: false });
        
        // Global move/up on SVG (captures outside handle region)
        this.svg.addEventListener("pointermove", (e) => this._onMove(e), { passive: false });
        this.svg.addEventListener("pointerup", (e) => this._endDrag(e), { passive: false });
        this.svg.addEventListener("pointercancel", (e) => this._endDrag(e), { passive: false });
        this.svg.addEventListener("lostpointercapture", (e) => this._endDrag(e), { passive: false });
      }
      
      _startDrag(e, mode) {
        e.preventDefault();
        
        // Only one pointer at a time
        if (this.drag.mode) return;
        
        this.drag.mode = mode;
        this.drag.pointerId = e.pointerId;
        this.svg.setPointerCapture?.(e.pointerId);
        
        const pt = this._toSvgPoint(e);
        this.drag.startPt = pt;
        this.drag.startRange = this._cloneRange(this.range);
        
        // For move, compute anchor offset in cell space to preserve grab point
        if (mode === "move") {
          const { start, end } = this._normalizedRangeFrom(this.drag.startRange);
          const rect = this._rectFor(start, end);
          // Convert pointer position into cell coords within rect (fractional)
          const fx = (pt.x - rect.x) / this.cellW;
          const fy = (pt.y - rect.y) / this.cellH;
          this.drag.moveAnchor = { fx, fy, w: (end.c - start.c + 1), h: (end.r - start.r + 1) };
        }
      }
      
      _onMove(e) {
        if (!this.drag.mode) return;
        if (e.pointerId !== this.drag.pointerId) return;
        e.preventDefault();
        
        const pt = this._toSvgPoint(e);
        
        if (this.drag.mode === "move") {
          this._dragMove(pt);
        } else if (this.drag.mode === "a") {
          this._dragHandle(pt, "a");
        } else if (this.drag.mode === "b") {
          this._dragHandle(pt, "b");
        }
        
        this.render(); // live feedback, no snapping until end
      }
      
      _endDrag(e) {
        if (!this.drag.mode) return;
        if (e.pointerId !== this.drag.pointerId) return;
        e.preventDefault();
        
        // Snap to grid on release (range is already in cell coords; ensure clamped + normalized)
        this._clampRangeInPlace();
        
        // Clear drag state
        this.drag.mode = null;
        this.drag.pointerId = null;
        this.drag.startPt = null;
        this.drag.startRange = null;
        this.drag.moveAnchor = null;
        
        this.render();
        this._emit();
      }
      
      _dragMove(pt) {
        const startRange = this.drag.startRange;
        const { start, end } = this._normalizedRangeFrom(startRange);
        const w = end.c - start.c + 1;
        const h = end.r - start.r + 1;
        
        // Anchor: maintain where you grabbed inside selection
        const anchor = this.drag.moveAnchor ?? { fx: 0.5, fy: 0.5, w, h };
        
        // Desired top-left in px
        const desiredX = pt.x - anchor.fx * this.cellW;
        const desiredY = pt.y - anchor.fy * this.cellH;
        
        // Convert to fractional cell top-left
        const fracC = (desiredX - this.opts.padding) / this.cellW;
        const fracR = (desiredY - this.opts.padding) / this.cellH;
        
        // For live drag, keep fractional by rounding to nearest cell boundary feel:
        // We keep it continuous but expressed as integer cell coords by nearest.
        let newStartC = Math.round(fracC);
        let newStartR = Math.round(fracR);
        
        // Clamp so selection stays within grid
        newStartC = this._clamp(newStartC, 0, this.cols - w);
        newStartR = this._clamp(newStartR, 0, this.rows - h);
        
        const newEndC = newStartC + w - 1;
        const newEndR = newStartR + h - 1;
        
        // Preserve orientation? Move should keep same shape; use normalized then set corners
        this.range.a = { r: newStartR, c: newStartC };
        this.range.b = { r: newEndR, c: newEndC };
      }
      
      _dragHandle(pt, which) {
        // Convert pointer to nearest cell for live feel (snaps on release anyway)
        const cell = this._pointToCell(pt.x, pt.y, /*nearest=*/ true);
        
        // Update chosen corner
        if (which === "a") this.range.a = cell;
        else this.range.b = cell;
        
        // Seamless inversion: nothing special needed besides allowing a/b to cross.
        // Rendering uses normalized range, so rectangle never flips weirdly.
      }
      
      // --- Rendering
      render() {
        const { start, end } = this._normalizedRange();
        
        // Update selection rect
        const rect = this._rectFor(start, end);
        this.selRect.setAttribute("x", rect.x);
        this.selRect.setAttribute("y", rect.y);
        this.selRect.setAttribute("width", rect.w);
        this.selRect.setAttribute("height", rect.h);
        
        // Update hit rect (slightly bigger for finger)
        const hitPad = 8;
        this.selHit.setAttribute("x", rect.x - hitPad);
        this.selHit.setAttribute("y", rect.y - hitPad);
        this.selHit.setAttribute("width", rect.w + hitPad * 2);
        this.selHit.setAttribute("height", rect.h + hitPad * 2);
        
        // Handles at two opposite corners (top-left == start, bottom-right == end)
        this._positionHandle(this.handleA, rect.x, rect.y);
        this._positionHandle(this.handleB, rect.x + rect.w, rect.y + rect.h);
        
        // Optional: readout demo
        const readout = document.getElementById("rangeReadout");
        if (readout) {
          readout.textContent =
            `Range: r${start.r}c${start.c} → r${end.r}c${end.c} (${end.r - start.r + 1}×${end.c - start.c + 1})`;
        }
      }
      
      _positionHandle(handle, x, y) {
        const r = this.opts.handleRadius;
        
        // Place circle centered on corner
        handle.circle.setAttribute("cx", x);
        handle.circle.setAttribute("cy", y);
        handle.circle.setAttribute("r", r);
        
        handle.hit.setAttribute("cx", x);
        handle.hit.setAttribute("cy", y);
        handle.hit.setAttribute("r", r * 1.8);
        
        // Drag glyph line inside circle
        handle.line.setAttribute("x1", x);
        handle.line.setAttribute("x2", x);
        handle.line.setAttribute("y1", y - r * 0.45);
        handle.line.setAttribute("y2", y + r * 0.45);
      }
      
      // --- Geometry helpers
      _pxX(c) { return this.opts.padding + c * this.cellW; }
      _pxY(r) { return this.opts.padding + r * this.cellH; }
      
      _rectFor(start, end) {
        const x = this._pxX(start.c);
        const y = this._pxY(start.r);
        const w = (end.c - start.c + 1) * this.cellW;
        const h = (end.r - start.r + 1) * this.cellH;
        // For handle placement at far corner, we want corner point exactly at rect boundary
        return { x, y, w, h };
      }
      
      _pointToCell(x, y, nearest) {
        const cRaw = (x - this.opts.padding) / this.cellW;
        const rRaw = (y - this.opts.padding) / this.cellH;
        
        let c = nearest ? Math.round(cRaw) : Math.floor(cRaw);
        let r = nearest ? Math.round(rRaw) : Math.floor(rRaw);
        
        c = this._clamp(c, 0, this.cols - 1);
        r = this._clamp(r, 0, this.rows - 1);
        return { r, c };
      }
      
      _toSvgPoint(e) {
        const svg = this.svg;
        const pt = svg.createSVGPoint();
        pt.x = e.clientX;
        pt.y = e.clientY;
        const ctm = svg.getScreenCTM();
        if (!ctm) return { x: 0, y: 0 };
        const inv = ctm.inverse();
        const sp = pt.matrixTransform(inv);
        return { x: sp.x, y: sp.y };
      }
      
      _normalizedRange() {
        return this._normalizedRangeFrom(this.range);
      }
      _normalizedRangeFrom(range) {
        const r1 = range.a.r,
          c1 = range.a.c;
        const r2 = range.b.r,
          c2 = range.b.c;
        const start = { r: Math.min(r1, r2), c: Math.min(c1, c2) };
        const end = { r: Math.max(r1, r2), c: Math.max(c1, c2) };
        return { start, end };
      }
      
      _clampRangeInPlace() {
        // range corners already integer; just clamp and keep inclusive
        this.range.a.r = this._clamp(this.range.a.r, 0, this.rows - 1);
        this.range.a.c = this._clamp(this.range.a.c, 0, this.cols - 1);
        this.range.b.r = this._clamp(this.range.b.r, 0, this.rows - 1);
        this.range.b.c = this._clamp(this.range.b.c, 0, this.cols - 1);
      }
      
      _cloneRange(r) {
        return { a: { r: r.a.r, c: r.a.c }, b: { r: r.b.r, c: r.b.c } };
      }
      
      _clamp(v, lo, hi) { return Math.max(lo, Math.min(hi, v)); }
      
      _el(tag, attrs = {}) {
        const el = document.createElementNS("http://www.w3.org/2000/svg", tag);
        for (const [k, v] of Object.entries(attrs)) el.setAttribute(k, String(v));
        return el;
      }
    }
    
    // --- Demo setup
    const svg = document.getElementById("sheet");
    
    // Pick a mobile-friendly cell size; feel free to change.
    const selector = new SvgRangeSelector(svg, {
      rows: 16,
      cols: 10,
      cellW: 32,
      cellH: 32,
      majorEvery: 4,
      handleRadius: 12,
      padding: 12,
    });
    
    // Listen for emitted range
    svg.addEventListener("rangechange", (e) => {
      // e.detail = { start:{r,c}, end:{r,c} }
      console.log("rangechange:", e.detail);
    });
    
    // Optional: start somewhere
    selector.placeAtCell(2, 2);
  </script>
</body>

</html>